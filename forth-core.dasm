include(`forth-macros.m4')

; Stack diagrams are read as follows:
;        BEFORE                AFTER
; ( bottom middle top -- bottom middle top )

	set pc, _START

:DOCOL
	PUSHRSP(i)
	add z, 1		; Move skip the DOCOL word
	set i, z		; Save in i to prepare for NEXT
	NEXT

:_START

; Stack manipulation

	DEFCODE(drop)		; Drop the top of stack
	set y, pop		; ( a -- )
	NEXT

	DEFCODE(swap)		; Swap the top two elements of the stack
	set a, y		; ( a b -- b a )
	set y, pop
	set push, a
	NEXT

	DEFCODE(dup)		; Duplicate the top of stack
	set push, y		; ( a -- a a )
	NEXT

	DEFCODE(over)		; Duplicate the second to top element to the top of stack
	set a, peek		; ( a b -- a b a )
	set push, y
	set y, a
	NEXT

	DEFCODE(rot)		; Move the third from top to the top
	set a, pop		; ( a b c -- b c a )
	set b, pop
	set push, a
	set push, y
	set y, b

	DEFCODE(`-rot',nrot)	; Moves the top of stack behind the next two
	set a, pop		; ( a b c -- c a b )
	set b, pop
	set push, y
	set push, b
	set y, a
	NEXT

	DEFCODE(2drop,twodrop)	; Drop the top two items on the stack
	add sp, 1		; ( a b -- )
	set y, pop
	NEXT

	DEFCODE(2swap,twoswap)	; Swap the top two pairs of elements
	set c, pop		; ( a b c d -- c d a b )
	set b, pop
	set a, pop
	set push, c
	set push, y
	set push, a
	set y, b
	NEXT

	DEFCODE(`?dup',qdup)	; Duplicate the top of stack if it's not zero
	ife y, 0
		set push, y
	NEXT

; Math operators
; By default, all operations are unsigned.
; Where the results differ, there should be a signed S-OP for every OP.

	DEFCODE(`1+',incr)	; Increment top of stack
	add y, 1
	NEXT

	DEFCODE(`1-',decr)	; Decrement top of stack
	sub a, 1
	NEXT

	DEFCODE(`+',add)	; Addition
	add y, pop
	NEXT

	DEFCODE(`-',sub)	; Subtraction
	sub y, pop
	NEXT

	DEFCODE(`*',mul)	; Multiplication (ignoring overflow)
	mul y, pop
	NEXT

	DEFCODE(`/',div)	; Division
	div y, pop
	NEXT

	DEFCODE(`s-/',`s-div')	; Division (signed)
	dvi y, pop
	NEXT

	DEFCODE(`%',mod)	; Modulus
	mod y, pop
	NEXT

	DEFCODE(`s-%',`s-mod')	; Modulus (signed)
	mdi y, pop
	NEXT

define(`TRUE', `0xFFFF')dnl
define(`FALSE',`0x0000')dnl
; Comparisons
; These are all ( a b -- bool ).
; A bool is `TRUE' = TRUE, `FALSE' = FALSE.
; Like the math ops, default is unsigned.

	DEFCODE(`=',equ)	; Equals
	set a, FALSE
	ife y, pop
		set a, TRUE
	set y, a
	NEXT

	DEFCODE(`<>',nequ)	; Not Equals
	set a, FALSE
	ifn y, pop
		set a, TRUE
	set y, a
	NEXT

	DEFCODE(`<',lt)		; Less Than
	set a, FALSE
	ifl y, pop
		set a, TRUE
	set y, a
	NEXT

	DEFCODE(`s-<',`s-lt')	; Less Than (signed)
	set a, FALSE
	ifu y, pop
		set a, TRUE
	set y, a
	NEXT

	DEFCODE(`>',gt)		; Greater Than
	set a, FALSE
	ifg y, pop
		set a, TRUE
	set y, a
	NEXT

	DEFCODE(`s->',`s-gt')	; Greater Than (signed)
	set a, FALSE
	ifa y, pop
		set a, TRUE
	set y, a
	NEXT

	DEFCODE(`<=',le)	; Less Than or Equal
	set a, TRUE
	set b, pop
	ifg b, y
		set a, FALSE
	set y, a
	NEXT

	DEFCODE(`s-<=',`s-le')	; Less Than or Equal (signed)
	set a, TRUE
	set b, pop
	ifa b, y
		set a, FALSE
	set y, a
	NEXT

	DEFCODE(`>=',ge)	; Greater Than or Equal
	set a, TRUE
	set b, pop
	ifl b, y
		set a, FALSE
	set y, a
	NEXT

	DEFCODE(`s->=',`s-ge')	; Greater Than or Equal (signed)
	set a, TRUE
	set b, pop
	ifu b, y
		set a, FALSE
	set y, a
	NEXT
