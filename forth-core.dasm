;; Copyright (c) 2012, Nick Meharry
;; All rights reserved.
;;
;; Redistribution and use in source and binary forms, with or without
;; modification, are permitted provided that the following conditions are met:
;; 	* Redistributions of source code must retain the above copyright
;; 	  notice, this list of conditions and the following disclaimer.
;; 	* Redistributions in binary form must reproduce the above copyright
;; 	  notice, this list of conditions and the following disclaimer in the
;; 	  documentation and/or other materials provided with the distribution.
;; 	* Neither the name of the <organization> nor the
;; 	  names of its contributors may be used to endorse or promote products
;; 	  derived from this software without specific prior written permission.
;;
;; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
;; ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
;; WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
;; DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
;; DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
;; (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES ;
;; LOSS OF USE, DATA, OR PROFITS ; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
;; ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
;; (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
;; SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

define(`__VERSION__', `1')
include(`forth-macros.m4')

;; This file was created by following the jonesforth tutorial.
;; See jonesforth.S and .f at http://git.annexia.org/?p=jonesforth.git;a=tree

; Stack diagrams are read as follows:
;        BEFORE                AFTER
; ( bottom middle top -- bottom middle top )

	set pc, _START

:DOCOL
	PUSHRSP(i)
	add z, 1		; Move skip the DOCOL word
	set i, z		; Save in i to prepare for NEXT
	NEXT

:_START

; Stack manipulation

	DEFCODE(drop)		; Drop the top of stack
	set y, pop		; ( a -- )
	NEXT

	DEFCODE(swap)		; Swap the top two elements of the stack
	set a, y		; ( a b -- b a )
	set y, pop
	set push, a
	NEXT

	DEFCODE(dup)		; Duplicate the top of stack
	set push, y		; ( a -- a a )
	NEXT

	DEFCODE(over)		; Duplicate the second to top element to the top of stack
	set a, peek		; ( a b -- a b a )
	set push, y
	set y, a
	NEXT

	DEFCODE(rot)		; Move the third from top to the top
	set a, pop		; ( a b c -- b c a )
	set b, pop
	set push, a
	set push, y
	set y, b

	DEFCODE(`-rot',nrot)	; Moves the top of stack behind the next two
	set a, pop		; ( a b c -- c a b )
	set b, pop
	set push, y
	set push, b
	set y, a
	NEXT

	DEFCODE(2drop,twodrop)	; Drop the top two items on the stack
	add sp, 1		; ( a b -- )
	set y, pop
	NEXT

	DEFCODE(2swap,twoswap)	; Swap the top two pairs of elements
	set c, pop		; ( a b c d -- c d a b )
	set b, pop
	set a, pop
	set push, c
	set push, y
	set push, a
	set y, b
	NEXT

	DEFCODE(`?dup',qdup)	; Duplicate the top of stack if it's not zero
	ife y, 0
		set push, y
	NEXT

; Math operators
; By default, all operations are unsigned.
; Where the results differ, there should be a signed S-OP for every OP.

	DEFCODE(`1+',incr)	; Increment top of stack
	add y, 1
	NEXT

	DEFCODE(`1-',decr)	; Decrement top of stack
	sub a, 1
	NEXT

	DEFCODE(`+',add)	; Addition
	add y, pop
	NEXT

	DEFCODE(`-',sub)	; Subtraction
	sub y, pop
	NEXT

	DEFCODE(`*',mul)	; Multiplication (ignoring overflow)
	mul y, pop
	NEXT

	DEFCODE(`/',div)	; Division
	div y, pop
	NEXT

	DEFCODE(`s-/',`s-div')	; Division (signed)
	dvi y, pop
	NEXT

	DEFCODE(`%',mod)	; Modulus
	mod y, pop
	NEXT

	DEFCODE(`s-%',`s-mod')	; Modulus (signed)
	mdi y, pop
	NEXT

define(`TRUE', `0xFFFF')dnl
define(`FALSE',`0x0000')dnl
; Comparisons
; These are all ( a b -- bool ).
; A bool is `TRUE' = TRUE, `FALSE' = FALSE.
; Like the math ops, default is unsigned.

	DEFCODE(`=',equ)	; Equals
	set a, FALSE
	ife y, pop
		set a, TRUE
	set y, a
	NEXT

	DEFCODE(`<>',nequ)	; Not Equals
	set a, FALSE
	ifn y, pop
		set a, TRUE
	set y, a
	NEXT

	DEFCODE(`<',lt)		; Less Than
	set a, FALSE
	ifl y, pop
		set a, TRUE
	set y, a
	NEXT

	DEFCODE(`s-<',`s-lt')	; Less Than (signed)
	set a, FALSE
	ifu y, pop
		set a, TRUE
	set y, a
	NEXT

	DEFCODE(`>',gt)		; Greater Than
	set a, FALSE
	ifg y, pop
		set a, TRUE
	set y, a
	NEXT

	DEFCODE(`s->',`s-gt')	; Greater Than (signed)
	set a, FALSE
	ifa y, pop
		set a, TRUE
	set y, a
	NEXT

	DEFCODE(`<=',le)	; Less Than or Equal
	set a, TRUE
	set b, pop
	ifg b, y
		set a, FALSE
	set y, a
	NEXT

	DEFCODE(`s-<=',`s-le')	; Less Than or Equal (signed)
	set a, TRUE
	set b, pop
	ifa b, y
		set a, FALSE
	set y, a
	NEXT

	DEFCODE(`>=',ge)	; Greater Than or Equal
	set a, TRUE
	set b, pop
	ifl b, y
		set a, FALSE
	set y, a
	NEXT

	DEFCODE(`s->=',`s-ge')	; Greater Than or Equal (signed)
	set a, TRUE
	set b, pop
	ifu b, y
		set a, FALSE
	set y, a
	NEXT

; Comparisons with zero
; These are all ( a -- bool )

	DEFCODE(`0=',zequ)	; Is zero?
	set a, FALSE
	ife y, 0
		set a, TRUE
	set y, a
	NEXT

	DEFCODE(`0<>',znequ)	; Is not zero?
	set a, FALSE
	ifn y, 0
		set a, TRUE
	set y, a
	NEXT

	DEFCODE(`0<',zlt)	; Less Than zero?
	set y, FALSE		; Really only makes sense as signed.
	NEXT

	DEFCODE(`s-0<',`s-zlt')	; Less Than zero? (signed)
	set a, FALSE
	ifu y, 0
		set a, TRUE
	set y, a
	NEXT

	DEFCODE(`0>',zgt)	; Greater Than zero?
	set y, TRUE		; Again, only makes sense as signed.
	NEXT

	DEFCODE(`s-0>',`s-zgt')	; Greater Than zero? (signed)
	set a, FALSE
	ifa y, 0
		set a, TRUE
	set y, a
	NEXT

	DEFCODE(`0<=',zle)	; Less Than or Equal to zero?
	set a, FALSE
	ife y, 0
		set a, TRUE
	set y, a
	NEXT

	DEFCODE(`s-0<=',`s-zle')	; Less Than or Equal to zero? (signed)
	set a, TRUE
	ifa y, 0
		set a, FALSE
	set y, a
	NEXT

	DEFCODE(`0>=',zge)	; Greater Than or Equal to zero?
	set y, TRUE
	NEXT

	DEFCODE(`s-0>=',`s-zge')	; Greater Than or Equal to zero? (signed)
	set a, TRUE
	ifu y, 0
		set a, FALSE
	set y, a
	NEXT

; Bitwise operators

	DEFCODE(and)	; Binary and (&)
	and y, pop	; ( a b -- c )
	NEXT

	DEFCODE(or)	; Binary or (|)
	bor y, pop	; ( a b -- c )
	NEXT

	DEFCODE(xor)	; Binary xor (^)
	xor y, pop	; ( a b -- c )
	NEXT

	DEFCODE(lshr)	; Logical shift right
	shr y, pop	; ( a b -- c )
	NEXT


	DEFCODE(ashr)	; Arithmetic shift right
	asr y, pop	; ( a b -- c )
	NEXT

	DEFCODE(lshl)	; Logical shift left
	shl y, pop	; ( a b -- c )
	NEXT

	DEFCODE(ashl)	; Arithmetic shift left (same as logical shift left)
	shl y, pop	; ( a b -- c )
	NEXT

	DEFCODE(invert)	; Invert all bits
	xor y, TRUE	; ( a -- b )
	NEXT

; Special words

	DEFCODE(exit)	; This goes at the end of all Forth level words,
	POPRSP(i)	; like NEXT is to assembly level words.
	NEXT

	DEFCODE(lit)	; Literal values
	set push, [i]	; Remember that i contains the next instruction.
	add i, 1  	; Push its value to the stack, and skip over it.

; Direct memory access

	DEFCODE(`!',store)
	set [y], pop
	set y, pop
	NEXT

	DEFCODE(`@',fetch)
	set y, [y]
	NEXT

	DEFCODE(`+!',addstore)
	add [y], pop
	set y, pop
	NEXT

	DEFCODE(`-!',substore)
	sub [y], pop
	set y, pop
	NEXT


; Variables and constants

	DEFVAR(state)	; Is the interpreter executing code (zero) or compiling a word (non-zero)
	DEFVAR(latest)	; Pointer to the last defined word
	DEFVAR(here)	; Pointer to the next free word of memory
	DEFVAR(s0,sz)	; Pointer to the top of the parameter stack
	DEFVAR(base,,,10)	; The current base for reading and printing numbers (2=binary, 16=hex, etc)
	DEFVAR(keyboard,,,0xFFFF)	; The identifier for the keyboard
	DEFVAR(monitor,,,0xFFFF)	; The identifier for the monitor
	DEFVAR(`monitor-base',,,0x8000)	; The base location for the monitor

	DEFCONST(version,,,__VERSION__)	; The current version of this Forth
	DEFCONST(r0,rz,,0xFFFF-0x100)	; Pointer to the top of the return stack
	DEFCONST(docol,__docol,,DOCOL)	; Pointer to DOCOL
	DEFCONST(f_immed,__f_immed,,F_IMMED)	; The IMMEDIATE flag's actual value
	DEFCONST(f_hidden,__f_hidden,,F_HIDDEN)	; The HIDDEN flag's actual value
	DEFCONST(f_lenmask,__f_lenmask,,F_LENMASK)	; The length mask in the flags/length word


; Return stack -- [j] is the top of the return stack

	DEFCODE(`>r',tor)	; Add item to return stack
	PUSHRSP(y)		; ( r -- )
	set y, pop
	NEXT

	DEFCODE(`r>',fromr)	; Remove item from return stack
	set push, y		; ( -- r )
	POPRSP(y)
	NEXT

	DEFCODE(`rsp@',rspfetch)	; Copy top of return stack
	set push, y			; ( -- r )
	set y, [j]
	NEXT

	DEFCODE(`rsp!',rspstore)	; Overwrite top of return stack
	set [j], y			; ( r -- )
	set y, pop
	NEXT

; Hardware
; There's a bit of a register sqeeze to deal with when querying for hardware.
; The HWQ instruction sets registers A, B, C, X, and Y.
; Register Y (top of stack) must be saved, and the other registers, Z, I, and J,
; are all in use by the Forth VM, meaning a lot of shuffling has to happen.

	DEFCODE(`hw-scan-id')	; Look for a particular hardware device by id
	set a, y		; ( id-high id-low -- device-idx )
	set b, pop		; device-idx is 0xFFFF if not found
	set push, i	; Save the interpreter's state on the stack
	set push, j	; so we can re-use these registers.
	set push, z
	set push, b	; Save the device id back on the stack
	set push, a
			; At this point, all registers are clear to use.
			; Stack looks like this:
			; ( I J Z id-high id-low )
			; Y is safe to overwrite, as it started holding id-low,
			;   which is now on the stack.
			; A, B, C, and X are by default safe to overwrite.
			; Now we can scan for hardware
	hwn y		; Get a count of attached devices
:hw_scan_id_loop
	hwq y		; Scan hardware into A, B, C, and X
	ifn peek, a	; We really only care about A and B
		set pc, hw_scan_id_fail
	ifn pick 1, b
		set pc, hw_scan_id_fail
:hw_scan_id_found	; It's a match!
	set pc, hw_scan_id_cleanup
:hw_scan_id_fail
	sub y, 1
	ife y, 0xFFFF
		set pc, hw_scan_id_cleanup
	set pc, hw_scan_id_loop
:hw_scan_id_cleanup	; Restore all the registers
	set a, pop	; ( I J Z id-high id-low )
	set a, pop	; device-idx is in y, just as it should be
	set z, pop	; Don't care about the id words any more
	set j, pop
	set i, pop
	NEXT

; Error messages

	DEFCODE(panic)			; Dump a message to the screen
	set a, pop			; and then crash, hanging forever :(
	set b, pop			; ( address length -- *no-return* )
	set x, [var_MONITOR_BASE]	; Register usage: a = lenth, b = address+a/2, x=MONITOR_BASE+a
	add x, a			;   c = current character (cleaned), i = odd flag
	div a, 2
	add b, a
	set i, 0
	ife [var_MONITOR], 0xFFFF	; All hope is lost, no video connected to show panic message
		set pc, panic_message_crash
:panic_message_loop
	ife a, 0	; End of message
		set pc, panic_message_crash
	set c, [b]  	; Currently, c is packed with two bytes
	ife i, 0	; If even, skip odd handling
		set pc, panic_message_even
	shr c, 8    	; Clear out the odd flag
:panic_message_even
	and c, 0x7f
	set [x], c	; Show the now cleaned character on screen
	sub a, 1
	sub x, 1
	add b, 2
	add [var_MONITOR_BASE], 1
	xor i, 1	; Toggle odd flag
	set pc, panic_message_loop
:panic_message_crash
	set pc, panic_message_crash

