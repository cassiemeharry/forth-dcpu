;; Copyright (c) 2012, Nick Meharry
;; All rights reserved.
;;
;; Redistribution and use in source and binary forms, with or without
;; modification, are permitted provided that the following conditions are met:
;; 	* Redistributions of source code must retain the above copyright
;; 	  notice, this list of conditions and the following disclaimer.
;; 	* Redistributions in binary form must reproduce the above copyright
;; 	  notice, this list of conditions and the following disclaimer in the
;; 	  documentation and/or other materials provided with the distribution.
;; 	* Neither the name of the <organization> nor the
;; 	  names of its contributors may be used to endorse or promote products
;; 	  derived from this software without specific prior written permission.
;;
;; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
;; ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
;; WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
;; DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
;; DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
;; (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES ;
;; LOSS OF USE, DATA, OR PROFITS ; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
;; ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
;; (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
;; SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

include(`forth-macros.m4')

;; This file was created by following the jonesforth tutorial.
;; See jonesforth.S and .f at http://git.annexia.org/?p=jonesforth.git;a=tree

; Stack diagrams are read as follows:
;        BEFORE                AFTER
; ( bottom middle top -- bottom middle top )

	set pc, _START

:DOCOL
	PUSHRSP(i)
	add z, 1		; Move skip the DOCOL word
	set i, z		; Save in i to prepare for NEXT
	NEXT

:_START

; Stack manipulation

	DEFCODE(drop)		; Drop the top of stack
	set y, pop		; ( a -- )
	NEXT

	DEFCODE(swap)		; Swap the top two elements of the stack
	set a, y		; ( a b -- b a )
	set y, pop
	set push, a
	NEXT

	DEFCODE(dup)		; Duplicate the top of stack
	set push, y		; ( a -- a a )
	NEXT

	DEFCODE(over)		; Duplicate the second to top element to the top of stack
	set a, peek		; ( a b -- a b a )
	set push, y
	set y, a
	NEXT

	DEFCODE(rot)		; Move the third from top to the top
	set a, pop		; ( a b c -- b c a )
	set b, pop
	set push, a
	set push, y
	set y, b

	DEFCODE(`-rot',nrot)	; Moves the top of stack behind the next two
	set a, pop		; ( a b c -- c a b )
	set b, pop
	set push, y
	set push, b
	set y, a
	NEXT

	DEFCODE(2drop,twodrop)	; Drop the top two items on the stack
	add sp, 1		; ( a b -- )
	set y, pop
	NEXT

	DEFCODE(2swap,twoswap)	; Swap the top two pairs of elements
	set c, pop		; ( a b c d -- c d a b )
	set b, pop
	set a, pop
	set push, c
	set push, y
	set push, a
	set y, b
	NEXT

	DEFCODE(`?dup',qdup)	; Duplicate the top of stack if it's not zero
	ife y, 0
		set push, y
	NEXT

; Math operators
; By default, all operations are unsigned.
; Where the results differ, there should be a signed S-OP for every OP.

	DEFCODE(`1+',incr)	; Increment top of stack
	add y, 1
	NEXT

	DEFCODE(`1-',decr)	; Decrement top of stack
	sub a, 1
	NEXT

	DEFCODE(`+',add)	; Addition
	add y, pop
	NEXT

	DEFCODE(`-',sub)	; Subtraction
	sub y, pop
	NEXT

	DEFCODE(`*',mul)	; Multiplication (ignoring overflow)
	mul y, pop
	NEXT

	DEFCODE(`/',div)	; Division
	div y, pop
	NEXT

	DEFCODE(`s-/',`s-div')	; Division (signed)
	dvi y, pop
	NEXT

	DEFCODE(`%',mod)	; Modulus
	mod y, pop
	NEXT

	DEFCODE(`s-%',`s-mod')	; Modulus (signed)
	mdi y, pop
	NEXT

define(`TRUE', `0xFFFF')dnl
define(`FALSE',`0x0000')dnl
; Comparisons
; These are all ( a b -- bool ).
; A bool is `TRUE' = TRUE, `FALSE' = FALSE.
; Like the math ops, default is unsigned.

	DEFCODE(`=',equ)	; Equals
	set a, FALSE
	ife y, pop
		set a, TRUE
	set y, a
	NEXT

	DEFCODE(`<>',nequ)	; Not Equals
	set a, FALSE
	ifn y, pop
		set a, TRUE
	set y, a
	NEXT

	DEFCODE(`<',lt)		; Less Than
	set a, FALSE
	ifl y, pop
		set a, TRUE
	set y, a
	NEXT

	DEFCODE(`s-<',`s-lt')	; Less Than (signed)
	set a, FALSE
	ifu y, pop
		set a, TRUE
	set y, a
	NEXT

	DEFCODE(`>',gt)		; Greater Than
	set a, FALSE
	ifg y, pop
		set a, TRUE
	set y, a
	NEXT

	DEFCODE(`s->',`s-gt')	; Greater Than (signed)
	set a, FALSE
	ifa y, pop
		set a, TRUE
	set y, a
	NEXT

	DEFCODE(`<=',le)	; Less Than or Equal
	set a, TRUE
	set b, pop
	ifg b, y
		set a, FALSE
	set y, a
	NEXT

	DEFCODE(`s-<=',`s-le')	; Less Than or Equal (signed)
	set a, TRUE
	set b, pop
	ifa b, y
		set a, FALSE
	set y, a
	NEXT

	DEFCODE(`>=',ge)	; Greater Than or Equal
	set a, TRUE
	set b, pop
	ifl b, y
		set a, FALSE
	set y, a
	NEXT

	DEFCODE(`s->=',`s-ge')	; Greater Than or Equal (signed)
	set a, TRUE
	set b, pop
	ifu b, y
		set a, FALSE
	set y, a
	NEXT

; Comparisons with zero
; These are all ( a -- bool )

	DEFCODE(`0=',zequ)	; Is zero?
	set a, FALSE
	ife y, 0
		set a, TRUE
	set y, a
	NEXT

	DEFCODE(`0<>',znequ)	; Is not zero?
	set a, FALSE
	ifn y, 0
		set a, TRUE
	set y, a
	NEXT

	DEFCODE(`0<',zlt)	; Less Than zero?
	set y, FALSE		; Really only makes sense as signed.
	NEXT

	DEFCODE(`s-0<',`s-zlt')	; Less Than zero? (signed)
	set a, FALSE
	ifu y, 0
		set a, TRUE
	set y, a
	NEXT

	DEFCODE(`0>',zgt)	; Greater Than zero?
	set y, TRUE		; Again, only makes sense as signed.
	NEXT

	DEFCODE(`s-0>',`s-zgt')	; Greater Than zero? (signed)
	set a, FALSE
	ifa y, 0
		set a, TRUE
	set y, a
	NEXT

	DEFCODE(`0<=',zle)	; Less Than or Equal to zero?
	set a, FALSE
	ife y, 0
		set a, TRUE
	set y, a
	NEXT

	DEFCODE(`s-0<=',`s-zle')	; Less Than or Equal to zero? (signed)
	set a, TRUE
	ifa y, 0
		set a, FALSE
	set y, a
	NEXT

	DEFCODE(`0>=',zge)	; Greater Than or Equal to zero?
	set y, TRUE
	NEXT

	DEFCODE(`s-0>=',`s-zge')	; Greater Than or Equal to zero? (signed)
	set a, TRUE
	ifu y, 0
		set a, FALSE
	set y, a
	NEXT

; Bitwise operators

	DEFCODE(and)	; Binary and (&)
	and y, pop	; ( a b -- c )
	NEXT

	DEFCODE(or)	; Binary or (|)
	bor y, pop	; ( a b -- c )
	NEXT

	DEFCODE(xor)	; Binary xor (^)
	xor y, pop	; ( a b -- c )
	NEXT

	DEFCODE(lshr)	; Logical shift right
	shr y, pop	; ( a b -- c )
	NEXT


	DEFCODE(ashr)	; Arithmetic shift right
	asr y, pop	; ( a b -- c )
	NEXT

	DEFCODE(lshl)	; Logical shift left
	shl y, pop	; ( a b -- c )
	NEXT

	DEFCODE(ashl)	; Arithmetic shift left (same as logical shift left)
	shl y, pop	; ( a b -- c )
	NEXT

	DEFCODE(invert)	; Invert all bits
	xor y, TRUE	; ( a -- b )
	NEXT

; Special words

	DEFCODE(exit)	; This goes at the end of all Forth level words,
	POPRSP(i)	; like NEXT is to assembly level words.
	NEXT

	DEFCODE(lit)	; Literal values
	set push, [i]	; Remember that i contains the next instruction.
	add i, 1  	; Push its value to the stack, and skip over it.
